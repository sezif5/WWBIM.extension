# Batch Operations - Пакетные операции

Документация скриптов для пакетной обработки моделей Revit.

---

## Скрипты

### 1. copy_adsk_mark.py
Копирование значения параметра `ADSK_Марка` в системный параметр `Марка`.

**Целевой параметр:** Марка (системный)
**Источник:** ADSK_Марка
**Категории:** Все модельные элементы (MODEL_CATEGORIES)

**Логика:**
- Добавляет параметр `ADSK_Марка` если отсутствует
- Копирует значение из `ADSK_Марка` в системный `Марка`
- Элементы без значения `ADSK_Марка` пропускаются

---

### 2. fill_filename.py
Заполнение параметра `ADSK_Имя_файла` именем файла модели.

**Целевой параметр:** ADSK_Имя_файла
**Источник:** Имя файла документа (doc.Title)

**Логика:**
- Берёт имя файла модели без расширения
- Записывает в параметр `ADSK_Имя_файла`
- Если у элемента уже есть значение - пропускает

---

### 3. fill_kit_code.py
Заполнение параметра `ADSK_КомплектШифр` на основе шифра комплекта листа.

**Целевой параметр:** ADSK_КомплектШифр
**Источник:** Параметр листа (ADSK_Штамп Раздел проекта, ADSK_Раздел проекта, Раздел проекта и др.)

**Режимы работы:**
1. **Schedules** (спецификации) - для AR, AI, НАВ, KM, KR
2. **Views** (виды) - для остальных моделей

**Логика:**
- Определяет режим по имени файла
- Определяет параметр листа с шифром комплекта
- Для спецификаций: берёт элементы из спецификации, присваивает шифр листа
- Для видов: берёт элементы из размещённых видов, присваивает шифр листа
- **Важное:** Шифр выбирается по кратчайшему (если элемент подходит под несколько шифров)
- Элемент заполняется только 1 раз (если уже есть значение - пропускается, или если новый короче - обновляется)

**Критерий выбора шифра:**
- Если у элемента нет значения → записать любой шифр
- Если у элемента есть значение → перезаписать только если новый шифр короче текущего

---

### 4. fill_section.py
Заполнение параметра `ADSK_Секция` на основе файла соответствия `album_section_mapping.txt`.

**Целевой параметр:** ADSK_Секция
**Источник:** Файл соответствия (Objects/album_section_mapping.txt)

**Логика:**
- Читает файл соответствия: `Альбом = Секция`
- Берёт значение параметра `ADSK_КомплектШифр` у элемента
- Определяет секцию по маппингу
- Записывает секцию в параметр `ADSK_Секция`

**Формат файла соответствия:**
```
АР = АР1
ВЖ = ВЖ1
КМ = КМ1
```

---

### 5. fill_section_from_filename.py
Заполнение параметра `ADSK_Секция` на основе имени файла модели.

**Целевой параметр:** ADSK_Секция
**Источник:** Имя файла документа

**Логика:**
- Разбирает имя файла по шаблону
- Извлекает код секции из имени (обычно первая часть до подчёркивания)
- Записывает в параметр `ADSK_Секция`

---

### 6. fill_underground_aboveground.py
Определение типа элемента (Подземный/Надземный) по координате Z.

**Целевой параметр:** ADSK_ПодземныйНадземный
**Источник:** Координата Z элемента (низ геометрии)

**Логика:**
- Получает геометрию элемента
- Определяет минимальную точку Z
- Если Z < 0 → "Подземный"
- Если Z >= 0 → "Надземный"
- Записывает в параметр `ADSK_ПодземныйНадземный`

---

### 7. fill_section_from_coordination.py ⭐
Заполнение параметра `ADSK_Секция` на основе объёмов (Антураж) в координационном файле.

**Целевой параметр:** ADSK_Секция
**Источник:** Объёмы категории "Антураж" в координационном файле

**Определение координационного файла:**
1. Ищет txt файл модели в папке `Objects`
2. Добавляет `_SERV` к имени txt файла
3. Читает путь к модели из координационного txt файла
4. Проверяет наличие `_CR_` в имени файла

**Пример:**
```
Модель: PT-test.rvt
Txt объекта: Objects/PT-test.txt
Txt координационный: Objects/PT-test_SERV.txt
Координационный файл: D:/Models/PT-test_CR_.rvt (если в txt)
```

**Логика работы:**
1. Открывает координационный файл в фоне (без интерфейса)
2. Находит все элементы категории "Антураж" с параметром `ADSK_Секция`
3. Для каждого объёма:
   - Получает геометрию (Solid)
   - Получает значение секции из параметра
   - Находит элементы в текущей модели, пересекающиеся с объёмом
   - Записывает номер секции в элементы
4. Закрывает координационный файл

**Обработка конфликтов:**
- Если элемент попал в разные объёмы с разными секциями → фиксирует конфликт
- При конфликте элемент остаётся с секцией первого объёма (не перезаписывается)

**Обработка категорий:**
- Скрипт пропускает категории, которые запрещают привязку параметров (`AllowsBoundParameters == False`)
- Например, категория "Опоры" будет пропущена и не вызовет ошибки
- Все пропущенные категории логируются в отчёт

**Отчёт о проблемах:**
- Пропущенные объёмы (без геометрии или без номера секции)
- Конфликты (элемент попал в разные объёмы)
- Ошибки записи параметра

---

## Общие параметры

Все скрипты поддерживают параметр `progress_callback` для отображения прогресса при выполнении в пакетном режиме.

Все скрипты возвращают словарь с полями:
```python
{
    "success": True/False,
    "message": "...",
    "parameters": {
        "added": ["имена добавленных параметров"],
        "existing": ["имена уже существующих"],
        "failed": ["имена параметров которые не удалось добавить"]
    },
    "fill": {
        "target_param": "имя целевого параметра",
        "source": "источник данных",
        "filled": True/False,
        "total_elements": 0,
        "updated_elements": 0,
        "skipped_elements": 0,
        "values": ["список уникальных значений"]
    }
}
```

---

## Зависимости

Все скрипты используют общие модули:
- `add_shared_parameter.py` - работа с общими параметрами
- `model_categories.py` - список модельных категорий
- `openbg.py` - открытие моделей в фоне
- `closebg.py` - закрытие моделей

---

## Особенности реализации

1. **Транзакции:**
   - Если документ уже модифицируется (`doc.IsModifiable == True`) - работает без транзакции
   - Иначе - создаёт транзакцию и корректно откатывает её при ошибке
   - Откат (RollBack) происходит только если транзакция реально была стартована

2. **Кодировка:**
   - Все файлы в UTF-8
   - Используется `from __future__ import unicode_literals`

3. **Совместимость с pyRevit:**
   - Используется `__file__` вместо `inspect.currentframe()`
   - Не используются вызовы `pyrevit.script` на верхнем уровне
   - Модули загружаются через `importlib.import_module()`

4. **Обработка категорий:**
   - Проверка `AllowsBoundParameters` перед привязкой параметра
   - Категории, не разрешающие привязку, пропускаются без ошибки
   - Все пропущенные категории логируются в отчёт
